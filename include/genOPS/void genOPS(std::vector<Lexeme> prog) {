void genOPS(std::vector<Lexeme> prog) {
    <string >OPS
    GenContext{prog, ["A", "Ʇ"], ["", ""]}
    for i:=0; i := range GenContext.magasine;  {

    }
}

Так помоги мне дописать эту функцию, её цель сгенерировать OPS, но не обычным способом, смотри у меня есть структура (которая возможно неправльно написнаа) -
struct GenContext {
    std::vector<Lexeme> prog
    std::vector<string> magasine
    std::vector<string> generator
    currentIdxProg
}

В ней есть prog - список распознанных лексем, вот структуа -
struct Lexeme {
    int num;             // номер лексемы
    std::string value;   // значение лексемы
    int row;             // строка
    int pos;             // столбец
};
Есть magasine -который содержит текущее правило, что такое правило? Вот тебе пример - 
начинаем мы всегда с  правила  - ["A", "Ʇ"] и генератора -[0, 0]
A - фактически программа, Ʇ - конец программы.
Мы смотрим на текущую лексему (её номер) и текущее правило (A), вот пример -
AꞱ, нам встретилась лексема - 13 значение scan, ищем правило в таблице genTransitionTable, вот тебе её опредление -

struct GenerationRules {
    std::vector<std::string> pattern;
    std::vector<std::int> action;
};

enum class GenState {
    A,
    P,
    Q,
    B,
    C, 
    D, 
    S,
    U,
    T,
    V,
    F,
    G,
    H,
    L,
    W,
    M,
    X,
    N,
    O,
    E,
    Z
};

using GenInnerMap = std::unordered_map<int, GenerationRules>;
using GenTable = std::unordered_map<GenState, GenInnerMap>;


А вот кусок её самой -
static const GenTable genTransitionTable = {
    { GenState::A, {
        { 1, { { "1", "H", "61", "S", "Z", "59", "A" }, { 1, 0, 0, 0, 61, 0, 0 } } },
        { 2, { { "" }, {  } } },
        { 3, { { "" }, {  } } },

Переходим по - genTransitionTable[A][13] и получаем -
 { "13", "40", "1", "H", "41", "59", "A" }, { 0, 0, 1, 0, 1101, 0, 0 } }

обьект типа -
struct GenerationRules {
    std::vector<std::string> pattern;
    std::vector<std::string> action;
};

Тут смотри - "13", "40", "1", "H", "41", "59", "A"
это то во что теперь преобразовывается A (заменяется)- то есть новый magasine теперь у нас такой - 
["13", "40", "a", "H", "41", "59", "A", "Ʇ"]
В генераторе КАЖДЫЙ ход цикла мы добавляем сиволм в OPS (ие я втом что пустой исмвол не поменяет OPS, пожтому не надо его проверять).
то есть в начале цикла мы пренесли один смивол из генератора в опс он стал таким -
[0], но у 13 правила есть свой генератор -{ 0, 0, 1, 0, 1101, 0, 0 }  его мы обящаны добавить к текущему генератору (как и с магазином)  в мамое начало, теперь у нас генератор вот такой -
[ 0, 0, 1, 0, 1101, 0, 0, 0] и заново по циклу! Причем программа идет свой ход только в случае если парвило и лексема совпадают, как это сделать? А вот так -
ЕСЛИ ПЕРВЫЙ СИМВОЛ В магазине совпадает с номером текущей лексемы (можно сравнить буквально вот попытавшись преобразовать символ из магазина в int)
Для просто ты пример -

текущие лексемы -
Lex 1: 'a' at (1:12)
Lex 60: '<' at (1:13)
Lex 2: '10' at (1:15)
Текущий магазин -
["1","H","V","U","O","X","W","41","A","Ʇ"]

преобразуем 1 в int и сравниваем с текущей лексемой - они равны! Удаляем символ из магазина и тепреь можем переходить к следующему символу в программе  -
Lex 60: '<' at (1:13)
Текущий магазин -
["H","V","U","O","X","W","41","A","Ʇ"]
H не получается преобразовать в int, значит обращаемся к genTransitionTable[H][60] получаем переход -
{ "" }, {  }
теперь наш магазин выглядит вот так -
["V","U","O","X","W","41","A","Ʇ"] (в магазине как раз атки и не может быть пустых символов). Генератор же в свою очередь вообще не меняется ведь нечего прибавлять (ЭТО ДАЖЕ НЕ ПУСТЫЕ СТРОКИ!)

Новая итерация -
Lex 60: '<' at (1:13)

["V","U","O","X","W","41","A","Ʇ"]
"V" не преобразовалась в число, смотрим в genTransitionTable[V][60]
опять { "" }, {  } }, 
теперь магазин такой -
["U","O","X","W","41","A","Ʇ"]

Еще итерация -
Lex 60: '<' at (1:13)

"U" не преоразуется в число, смотрим в  genTransitionTable[U][60]
{ "" }, {  } } 
теперь магазин -
["O","X","W","41","A","Ʇ"]

Еще итерация по магазину -
Lex 60: '<' at (1:13)
"O" не преобращуется, чсмотрим в genTransitionTable[O][60]
 { "60", "S", "Z" }, { 0, 0, 60 } 
 Теперь наш магазин -
 ["60", "S", "Z", "X","W","41","A","Ʇ"] (в генератор добавились в начало {0, 0, 60})

Еще итерация -
"60" преоьразовалось в число!!!! 
теперь к следующей лексеме -
Lex 2: '10' at (1:15)
Теперь наш магазин вот такой -
["S", "Z", "X","W","41","A","Ʇ"]

И так далее, пока магазин не будет пустым!!!!